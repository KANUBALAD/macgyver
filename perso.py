import position as Position
from labyManager import LabyManager
from constantes import *


class Perso:
	def __init__(self, pos, hasEther=False, hasTube=False, hasNeedle=False, alive=True):
		"""instance attributes: a position, objects to recover, a life"""
		self.pos = pos
		self.alive = alive
		self.hasEther = hasEther
		self.hasTube = hasTube
		self.hasNeedle = hasNeedle



	def __str__(self):
		"""returns a" descriptive "about the state (attributes) of the character in the terminal"""
		"""ps: special method to display the object with print"""
		description = "Perso position:\n" + str(self.pos) + "\n"
		description += "alive: " + str(self.alive) + '\n'
		description += "has needle: " + str(self.hasNeedle) + '\n'
		description += "has ether: " + str(self.hasEther) + '\n'
		description += "has tube: " + str(self.hasTube) + '\n'
		return description


	def goLeft(self, labyManager):
		goingToPos = Position.Position(self.pos.line, self.pos.column - 1)
		"""its future position, a left column -1 (+1 for right, +1 on the line to go down, -1 to go up)"""
		self.willStepOnObject(goingToPos, labyManager)
		"""an object and life test cf. willStep method ... below"""
		if labyManager.charAtPosition(goingToPos) != "*" and self.pos.column > 0:
			"""if the future position is not the wall and it is not already on the 1st column then:"""
			labyManager.updatePersoPositionInLaby(self.pos, goingToPos)
			"""we update the elements of the laby, the 8 (i.e. mac) moves to the left and the old position becomes empty"""
			self.pos = goingToPos
			"""the position = the new position, which allows to start again in the loop with this new state of position"""
		else:
			pass
			"""nothing happens, back in the loop and waiting for the new direction given"""
    	

	def goRight(self, labyManager):
		goingToPos = Position.Position(self.pos.line, self.pos.column + 1)
		self.willStepOnObject(goingToPos, labyManager)
		if labyManager.charAtPosition(goingToPos) != "*" and self.pos.column < len(labyManager.laby[self.pos.line]) - 1:
			"""if the future position is not the wall and it is not already on the last column of its line then:"""
			labyManager.updatePersoPositionInLaby(self.pos, goingToPos)
			"""we update the elements of the laby, the 8 (i.e. mac) moves to the right and the old position becomes empty"""
			self.pos = goingToPos
		else:
			pass
    	

	def goUp(self, labyManager):
		"""idem cf. goLeft for more explnantions"""
		goingToPos = Position.Position(self.pos.line - 1, self.pos.column)
		self.willStepOnObject(goingToPos, labyManager)
		if labyManager.charAtPosition(goingToPos) != "*" and self.pos.line > 0:
			labyManager.updatePersoPositionInLaby(self.pos, goingToPos)
			self.pos = goingToPos
		else:
			pass
    	

	def goDown(self, labyManager):
		"""idem cf. goLeft for more explanations"""
		goingToPos = Position.Position(self.pos.line + 1, self.pos.column)
		"""generated by the K_DOWN movement"""
		self.willStepOnObject(goingToPos, labyManager) #aucune action si goingToPos = * = un mur
		if labyManager.charAtPosition(goingToPos) != "*" and self.pos.line < len(labyManager.laby) - 1:
			labyManager.updatePersoPositionInLaby(self.pos, goingToPos)
			self.pos = goingToPos
		else:
			pass

	def willStepOnObject(self, pos, labyManager):
		"""if the next position is a wall i.e. "*" no change of target to True. QED"""
		if labyManager.charAtPosition(pos) == 'N':
			"""if the next position == N, then the attribute changes to True"""
			self.hasNeedle = True
		elif labyManager.charAtPosition(pos) == 'E':
			self.hasEther = True
		elif labyManager.charAtPosition(pos) == 'T':
			self.hasTube = True
		elif labyManager.charAtPosition(pos) == 'X':
			if not self.hasAllObjects():
				"""if Mac does not have all the objects, the guard will kill it => exit from the game_loop"""
				self.alive = False
	

	def hasAllObjects(self):
		"""returns False if a 3 of the instance attributes is False"""
		"""Returns True if Mac has (i.e. passed) on all 3 objects (all True)"""
		return self.hasNeedle and self.hasTube and self.hasEther


	
